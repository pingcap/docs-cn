---
title: 位函数和运算符
summary: 了解位函数和运算符。
---

# 位函数和运算符

TiDB 支持 MySQL 8.0 中提供的所有[位函数和运算符](https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html)。

**位函数和运算符：**

| 名称 | 描述 |
| :------| :------------- |
| [`BIT_COUNT()`](#bit_count) | 返回值为 1 的位数 |
| [<code>&</code>](#-bitwise-and) | 按位与 |
| [<code>~</code>](#-bitwise-inversion) | 按位取反 |
| [<code>\|</code>](#-bitwise-or) | 按位或 |
| [`^`](#-bitwise-xor) | 按位异或 |
| [`<<`](#-left-shift) | 左移 |
| [`>>`](#-right-shift) | 右移 |

## [`BIT_COUNT()`](https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#function_bit-count)

`BIT_COUNT(expr)` 函数返回 `expr` 中值为 1 的位数。

```sql
SELECT BIT_COUNT(b'00101001');
```

```
+------------------------+
| BIT_COUNT(b'00101001') |
+------------------------+
|                      3 |
+------------------------+
1 row in set (0.00 sec)
```

> **注意：**
>
> 如果参数 `expr` 是二进制数，你需要在数字前明确指定 `b`，例如 `b'00101001'`。否则，此函数会将其视为字符串并返回不同的结果。例如，`BIT_COUNT('00101001')` 返回 `7`，因为它将字符串 `'00101001'` 转换为十进制数 `101001`，并计算其二进制格式 `11000100001010001` 中 `1` 的位数。

以下示例与前面的类似，但使用十六进制字面量而不是位字面量作为参数。`CONV()` 函数将 `0x29` 从十六进制（基数 16）转换为二进制（基数 2），显示其二进制表示为 `00101001`。

```sql
SELECT BIT_COUNT(0x29), CONV(0x29,16,2);
```

```
+-----------------+-----------------+
| BIT_COUNT(0x29) | CONV(0x29,16,2) |
+-----------------+-----------------+
|               3 | 101001          |
+-----------------+-----------------+
1 row in set (0.01 sec)
```

`BIT_COUNT(expr)` 函数的一个实际用途是将网络掩码转换为 [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) 表示法。在以下示例中，网络掩码 `255.255.255.0` 被转换为其 CIDR 表示 `24`。

```sql
SELECT BIT_COUNT(INET_ATON('255.255.255.0'));
```

```
+---------------------------------------+
| BIT_COUNT(INET_ATON('255.255.255.0')) |
+---------------------------------------+
|                                    24 |
+---------------------------------------+
1 row in set (0.00 sec)
```

## [`&`（按位与）](https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-and)

`&` 运算符执行按位与运算。它比较两个数字的对应位：如果两个对应位都为 1，则结果的对应位为 1；否则为 0。

例如，`1010` 和 `1100` 之间的按位与运算返回 `1000`，因为只有最左边的位在两个数字中都设置为 1。

```
  1010
& 1100
  ----
  1000
```

在 SQL 中，你可以如下使用 `&` 运算符：

```sql
SELECT CONV(b'1010' & b'1000',10,2);
```

```
+------------------------------+
| CONV(b'1010' & b'1000',10,2) |
+------------------------------+
| 1000                         |
+------------------------------+
1 row in set (0.00 sec)
```

你可以将 `&` 运算符与 `INET_NTOA()` 和 `INET_ATON()` 函数一起使用，对 IP 地址和网络掩码执行按位与运算以获取网络地址。这对于确定多个 IP 地址是否属于同一网络非常有用。

在以下两个示例中，IP 地址 `192.168.1.1` 和 `192.168.1.2` 在与 `255.255.255.0` 掩码后都属于同一网络 `192.168.1.0/24`。

```sql
SELECT INET_NTOA(INET_ATON('192.168.1.1') & INET_ATON('255.255.255.0'));
```

```
+------------------------------------------------------------------+
| INET_NTOA(INET_ATON('192.168.1.1') & INET_ATON('255.255.255.0')) |
+------------------------------------------------------------------+
| 192.168.1.0                                                      |
+------------------------------------------------------------------+
1 row in set (0.00 sec)
```

```sql
SELECT INET_NTOA(INET_ATON('192.168.1.2') & INET_ATON('255.255.255.0'));
```

```
+------------------------------------------------------------------+
| INET_NTOA(INET_ATON('192.168.1.2') & INET_ATON('255.255.255.0')) |
+------------------------------------------------------------------+
| 192.168.1.0                                                      |
+------------------------------------------------------------------+
1 row in set (0.00 sec)
```

## [`~`（按位取反）](https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-invert)

`~` 运算符对给定值执行按位取反（或按位非）运算。它对给定值的每一位进行取反：0 变为 1，1 变为 0。

在运算之前，该值会被扩展为 64 位。

以二进制数 `1111000011110000` 为例。当扩展到 64 位并取反时，它看起来是这样的：

```
原始（16 位）：                                                                    1111000011110000
扩展并取反（64 位）：    1111111111111111111111111111111111111111111111110000111100001111
```

在 SQL 中，你可以如下使用 `~` 运算符：

```sql
SELECT CONV(~ b'1111000011110000',10,2);
+------------------------------------------------------------------+
| CONV(~ b'1111000011110000',10,2)                                 |
+------------------------------------------------------------------+
| 1111111111111111111111111111111111111111111111110000111100001111 |
+------------------------------------------------------------------+
1 row in set (0.00 sec)
```

你可以通过对结果再次应用 `~` 运算符来反转取反操作：

```sql
SELECT CONV(~ b'1111111111111111111111111111111111111111111111110000111100001111',10,2);
```

```
+----------------------------------------------------------------------------------+
| CONV(~ b'1111111111111111111111111111111111111111111111110000111100001111',10,2) |
+----------------------------------------------------------------------------------+
| 1111000011110000                                                                 |
+----------------------------------------------------------------------------------+
1 row in set (0.00 sec)
```

## [`|`（按位或）](https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-or)

`|` 运算符执行按位或运算。它比较两个数字的对应位：如果至少一个对应位为 1，则结果中的对应位为 1。

例如，`1010` 和 `1100` 之间的按位或运算返回 `1110`，因为在两个数字的前三位中，至少有一个对应位设置为 1。

```
  1010
| 1100
  ----
  1110
```

在 SQL 中，你可以如下使用 `|` 运算符：

```sql
SELECT CONV(b'1010' | b'1100',10,2);
```

```
+------------------------------+
| CONV(b'1010' | b'1100',10,2) |
+------------------------------+
| 1110                         |
+------------------------------+
1 row in set (0.00 sec)
```

## [`^`（按位异或）](https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-xor)

`^` 运算符执行按位异或（XOR）运算。它比较两个数字的对应位：如果对应位不同，则结果中的对应位为 1。

例如，`1010` 和 `1100` 之间的按位异或运算返回 `0110`，因为两个数字的第二位和第三位是不同的。

```
  1010
^ 1100
  ----
  0110
```

在 SQL 中，你可以如下使用 `^` 运算符：

```sql
SELECT CONV(b'1010' ^ b'1100',10,2);
```

```
+------------------------------+
| CONV(b'1010' ^ b'1100',10,2) |
+------------------------------+
| 110                          |
+------------------------------+
1 row in set (0.00 sec)
```

注意结果显示为 `110` 而不是 `0110`，因为前导零被删除了。

## [`<<`（左移）](https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_left-shift)

`<<` 运算符执行左移运算，将数字的位向左移动指定的位数，在右侧用零填充空出的位。

例如，以下语句使用 `1<<n` 将二进制值 `1` 向左移动 `n` 个位置：

```sql
WITH RECURSIVE cte(n) AS (
    SELECT 0 AS n
    UNION ALL
    SELECT 1+n FROM cte WHERE n<10
)
SELECT n,1<<n,LPAD(CONV(1<<n,10,2),11,0) FROM cte;
```

```
+------+------+----------------------------+
| n    | 1<<n | LPAD(CONV(1<<n,10,2),11,0) |
+------+------+----------------------------+
|    0 |    1 | 00000000001                |
|    1 |    2 | 00000000010                |
|    2 |    4 | 00000000100                |
|    3 |    8 | 00000001000                |
|    4 |   16 | 00000010000                |
|    5 |   32 | 00000100000                |
|    6 |   64 | 00001000000                |
|    7 |  128 | 00010000000                |
|    8 |  256 | 00100000000                |
|    9 |  512 | 01000000000                |
|   10 | 1024 | 10000000000                |
+------+------+----------------------------+
11 rows in set (0.00 sec)
```

## [`>>`（右移）](https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_right-shift)

`>>` 运算符执行右移运算，将数字的位向右移动指定的位数，在左侧用零填充空出的位。

例如，以下语句使用 `1024>>n` 将值 `1024`（二进制为 `10000000000`）向右移动 `n` 个位置：

```sql
WITH RECURSIVE cte(n) AS (
    SELECT 0 AS n
    UNION ALL
    SELECT n+1 FROM cte WHERE n<11
)
SELECT n,1024>>n,LPAD(CONV(1024>>n,10,2),11,0) FROM cte;
```

```
+------+---------+-------------------------------+
| n    | 1024>>n | LPAD(CONV(1024>>n,10,2),11,0) |
+------+---------+-------------------------------+
|    0 |    1024 | 10000000000                   |
|    1 |     512 | 01000000000                   |
|    2 |     256 | 00100000000                   |
|    3 |     128 | 00010000000                   |
|    4 |      64 | 00001000000                   |
|    5 |      32 | 00000100000                   |
|    6 |      16 | 00000010000                   |
|    7 |       8 | 00000001000                   |
|    8 |       4 | 00000000100                   |
|    9 |       2 | 00000000010                   |
|   10 |       1 | 00000000001                   |
|   11 |       0 | 00000000000                   |
+------+---------+-------------------------------+
12 rows in set (0.00 sec)
```

`>>` 运算符还可用于从较大的数字中提取特定部分，例如从 TiDB [TSO](/tso.md) 时间戳中提取 UNIX 时间戳。

## MySQL 兼容性

MySQL 8.0 和早期版本的 MySQL 在处理位函数和运算符方面存在一些差异。TiDB 旨在遵循 MySQL 8.0 的行为。

## 已知问题

在以下情况下，TiDB 中的查询结果与 MySQL 5.7 相同，但与 MySQL 8.0 不同。

- 带有二进制参数的位运算。更多信息，请参见 [#30637](https://github.com/pingcap/tidb/issues/30637)。
- `BIT_COUNT()` 函数的结果。更多信息，请参见 [#44621](https://github.com/pingcap/tidb/issues/44621)。
