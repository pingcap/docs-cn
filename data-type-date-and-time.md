---
title: 日期和时间类型
summary: 了解支持的日期和时间类型。
---

# 日期和时间类型

TiDB 支持所有 MySQL 日期和时间数据类型来存储时间值：[`DATE`](#date-类型)、[`TIME`](#time-类型)、[`DATETIME`](#datetime-类型)、[`TIMESTAMP`](#timestamp-类型) 和 [`YEAR`](#year-类型)。更多信息，请参见 [MySQL 中的日期和时间数据类型](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-types.html)。

每种类型都有其有效值范围，并使用零值来表示无效值。此外，`TIMESTAMP` 和 `DATETIME` 类型可以在修改时自动生成新的时间值。

在处理日期和时间值类型时，请注意：

+ 虽然 TiDB 尝试解释不同的格式，但日期部分必须采用年-月-日格式（例如 '1998-09-04'），而不是月-日-年或日-月-年格式。
+ 如果日期的年份部分指定为 2 位数字，TiDB 会根据[特定规则](#日期中包含的两位数年份)进行转换。
+ 如果在上下文中需要数值，TiDB 会自动将日期或时间值转换为数值类型。例如：

    ```sql
    mysql> SELECT NOW(), NOW()+0, NOW(3)+0;
    +---------------------+----------------+--------------------+
    | NOW()               | NOW()+0        | NOW(3)+0           |
    +---------------------+----------------+--------------------+
    | 2012-08-15 09:28:00 | 20120815092800 | 20120815092800.889 |
    +---------------------+----------------+--------------------+
    ```

+ TiDB 可能会自动将无效值或超出支持范围的值转换为该类型的零值。此行为取决于设置的 SQL 模式。例如：

    ```sql
    mysql> show create table t1;
    +-------+---------------------------------------------------------------------------------------------------------+
    | Table | Create Table                                                                                            |
    +-------+---------------------------------------------------------------------------------------------------------+
    | t1    | CREATE TABLE `t1` (
      `a` time DEFAULT NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin |
    +-------+---------------------------------------------------------------------------------------------------------+
    1 row in set (0.00 sec)

    mysql> select @@sql_mode;
    +-------------------------------------------------------------------------------------------------------------------------------------------+
    | @@sql_mode                                                                                                                                |
    +-------------------------------------------------------------------------------------------------------------------------------------------+
    | ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION |
    +-------------------------------------------------------------------------------------------------------------------------------------------+
    1 row in set (0.00 sec)

    mysql> insert into t1 values ('2090-11-32:22:33:44');
    ERROR 1292 (22007): Truncated incorrect time value: '2090-11-32:22:33:44'
    mysql> set @@sql_mode='';                                                                                                                                                                                                                     Query OK, 0 rows affected (0.01 sec)

    mysql> insert into t1 values ('2090-11-32:22:33:44');
    Query OK, 1 row affected, 1 warning (0.01 sec)

    mysql> select * from t1;
    +----------+
    | a        |
    +----------+
    | 00:00:00 |
    +----------+
    1 row in set (0.01 sec)
    ```

+ 设置不同的 SQL 模式可以改变 TiDB 的行为。
+ 如果未启用 SQL 模式 `NO_ZERO_DATE`，TiDB 允许 `DATE` 和 `DATETIME` 列中的月份或日期为零值，例如 '2009-00-00' 或 '2009-01-00'。如果这种日期类型要在函数中计算，例如在 `DATE_SUB()` 或 `DATE_ADD()` 中，结果可能不正确。
+ 默认情况下，TiDB 启用 SQL 模式 `NO_ZERO_DATE`。此模式防止存储零值，如 '0000-00-00'。

不同类型的零值如下表所示：

| 日期类型   | "零" 值 |
| :------   |  :----  |
| DATE      | '0000-00-00' |
| TIME      | '00:00:00'   |
| DATETIME  | '0000-00-00 00:00:00' |
| TIMESTAMP | '0000-00-00 00:00:00' |
| YEAR      | 0000         |

如果 SQL 模式允许这种用法，无效的 `DATE`、`DATETIME`、`TIMESTAMP` 值会自动转换为相应类型的零值（'0000-00-00' 或 '0000-00-00 00:00:00'）。

## 支持的类型

### `DATE` 类型

`DATE` 只包含日期部分而没有时间部分，以 `YYYY-MM-DD` 格式显示。支持的范围是 '0000-01-01' 到 '9999-12-31'：

```sql
DATE
```

### `TIME` 类型

对于 `TIME` 类型，格式为 `HH:MM:SS[.fraction]`，有效值范围从 '-838:59:59.000000' 到 '838:59:59.000000'。`TIME` 不仅用于表示一天内的时间，还用于表示两个事件之间的时间间隔。可以指定一个可选的 `fsp` 值，范围从 0 到 6，用于指定小数秒精度。如果省略，默认精度为 0：

```sql
TIME[(fsp)]
```

> **注意：**
>
> 注意 `TIME` 的缩写形式。例如，'11:12' 表示 '11:12:00' 而不是 '00:11:12'。但是，'1112' 表示 '00:11:12'。这些差异是由 `:` 字符的存在或缺失造成的。

### `DATETIME` 类型

`DATETIME` 同时包含日期部分和时间部分。有效值范围从 '0000-01-01 00:00:00.000000' 到 '9999-12-31 23:59:59.999999'。

TiDB 以 `YYYY-MM-DD HH:MM:SS[.fraction]` 格式显示 `DATETIME` 值，但允许使用字符串或数字为 `DATETIME` 列赋值。可以指定一个可选的 fsp 值，范围从 0 到 6，用于指定小数秒精度。如果省略，默认精度为 0：

```sql
DATETIME[(fsp)]
```

### `TIMESTAMP` 类型

`TIMESTAMP` 同时包含日期部分和时间部分。有效值范围从 '1970-01-01 00:00:01.000000' 到 '2038-01-19 03:14:07.999999'（UTC 时间）。可以指定一个可选的 fsp 值，范围从 0 到 6，用于指定小数秒精度。如果省略，默认精度为 0。

在 `TIMESTAMP` 中，不允许月份部分或日期部分出现零值。唯一的例外是零值本身 '0000-00-00 00:00:00'。

```sql
TIMESTAMP[(fsp)]
```

#### 时区处理

当存储 `TIMESTAMP` 时，TiDB 将 `TIMESTAMP` 值从当前时区转换为 UTC 时区。当检索 `TIMESTAMP` 时，TiDB 将存储的 `TIMESTAMP` 值从 UTC 时区转换为当前时区（注意：`DATETIME` 不会这样处理）。每个连接的默认时区是服务器的本地时区，可以通过环境变量 `time_zone` 修改。

> **警告：**
>
> 与 MySQL 一样，`TIMESTAMP` 数据类型受到 [2038 年问题](https://en.wikipedia.org/wiki/Year_2038_problem)的影响。对于可能跨越 2038 年的值，请考虑使用 `DATETIME` 类型。

### `YEAR` 类型

`YEAR` 类型以 'YYYY' 格式指定。支持的值范围从 1901 到 2155，或零值 0000：

```sql
YEAR[(4)]
```

`YEAR` 遵循以下格式规则：

+ 四位数字范围从 1901 到 2155
+ 四位字符串范围从 '1901' 到 '2155'
+ 一位或两位数字范围从 1 到 99。相应地，1-69 转换为 2001-2069，70-99 转换为 1970-1999
+ 一位或两位字符串范围从 '0' 到 '99'
+ 值 0 被视为 0000，而字符串 '0' 或 '00' 被视为 2000

无效的 `YEAR` 值会自动转换为 0000（如果用户没有使用 `NO_ZERO_DATE` SQL 模式）。

## `TIMESTAMP` 和 `DATETIME` 的自动初始化和更新

具有 `TIMESTAMP` 或 `DATETIME` 值类型的列可以自动初始化或更新为当前时间。

对于表中任何具有 `TIMESTAMP` 或 `DATETIME` 值类型的列，你可以将默认值或自动更新值设置为当前时间戳。

这些属性可以通过在定义列时设置 `DEFAULT CURRENT_TIMESTAMP` 和 `ON UPDATE CURRENT_TIMESTAMP` 来设置。DEFAULT 也可以设置为特定值，如 `DEFAULT 0` 或 `DEFAULT '2000-01-01 00:00:00'`。

```sql
CREATE TABLE t1 (
    ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    dt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

`DATETIME` 的默认值是 `NULL`，除非指定为 `NOT NULL`。对于后者，如果没有设置默认值，默认值为 0。

```sql
CREATE TABLE t1 (
    dt1 DATETIME ON UPDATE CURRENT_TIMESTAMP,         -- 默认 NULL
    dt2 DATETIME NOT NULL ON UPDATE CURRENT_TIMESTAMP -- 默认 0
);
```

## 时间值的小数部分

`DATETIME` 和 `TIMESTAMP` 值可以包含最多 6 位的小数部分，精确到微秒。在 `DATETIME` 或 `TIMESTAMP` 类型的任何列中，小数部分会被存储而不是被丢弃。带有小数部分的值的格式为 'YYYY-MM-DD HH:MM:SS[.fraction]'，小数部分范围从 000000 到 999999。必须使用小数点来分隔小数部分和其余部分。

+ 使用 `type_name(fsp)` 定义支持小数精度的列，其中 `type_name` 可以是 `TIME`、`DATETIME` 或 `TIMESTAMP`。例如，

    ```sql
    CREATE TABLE t1 (t TIME(3), dt DATETIME(6));
    ```

  `fsp` 必须在 0 到 6 之间。

  `0` 表示没有小数部分。如果省略 `fsp`，默认为 0。

+ 当插入包含小数部分的 `TIME`、`DATETIME` 或 `TIMESTAMP` 时，如果小数部分的位数太少或太多，可能需要进行舍入。例如：

    ```sql
    mysql> CREATE TABLE fractest( c1 TIME(2), c2 DATETIME(2), c3 TIMESTAMP(2) );
    Query OK, 0 rows affected (0.33 sec)

    mysql> INSERT INTO fractest VALUES
         > ('17:51:04.777', '2014-09-08 17:51:04.777',   '2014-09-08 17:51:04.777');
    Query OK, 1 row affected (0.03 sec)

    mysql> SELECT * FROM fractest;
    +-------------|------------------------|------------------------+
    | c1          | c2                     | c3                     |
    +-------------|------------------------|------------------------+
    | 17:51:04.78 | 2014-09-08 17:51:04.78 | 2014-09-08 17:51:04.78 |
    +-------------|------------------------|------------------------+
    1 row in set (0.00 sec)
    ```

## 日期和时间类型之间的转换

有时我们需要在日期和时间类型之间进行转换。但某些转换可能导致信息丢失。例如，`DATE`、`DATETIME` 和 `TIMESTAMP` 值都有各自的范围。`TIMESTAMP` 在 UTC 时间中不应早于 1970 年或晚于 UTC 时间 '2038-01-19 03:14:07'。基于此规则，'1968-01-01' 是 `DATE` 或 `DATETIME` 的有效日期值，但当转换为 `TIMESTAMP` 时变为 0。

`DATE` 的转换：

+ 当 `DATE` 转换为 `DATETIME` 或 `TIMESTAMP` 时，会添加时间部分 '00:00:00'，因为 DATE 不包含任何时间信息
+ 当 `DATE` 转换为 `TIME` 时，结果为 '00:00:00'

`DATETIME` 或 `TIMESTAMP` 的转换：

+ 当 `DATETIME` 或 `TIMESTAMP` 转换为 `DATE` 时，时间和小数部分会被丢弃。例如，'1999-12-31 23:59:59.499' 转换为 '1999-12-31'
+ 当 `DATETIME` 或 `TIMESTAMP` 转换为 TIME 时，日期部分会被丢弃，因为 `TIME` 不包含任何日期信息

当我们将 `TIME` 转换为其他时间和日期格式时，日期部分会自动指定为 `CURRENT_DATE()`。最终转换的结果是由 `TIME` 和 `CURRENT_DATE()` 组成的日期。这意味着如果 TIME 的值超出 '00:00:00' 到 '23:59:59' 的范围，转换后的日期部分不表示当前日期。

当 `TIME` 转换为 `DATE` 时，过程类似，时间部分会被丢弃。

使用 `CAST()` 函数可以显式地将值转换为 `DATE` 类型。例如：

```sql
date_col = CAST(datetime_col AS DATE)
```

将 `TIME` 和 `DATETIME` 转换为数值格式。例如：

```sql
mysql> SELECT CURTIME(), CURTIME()+0, CURTIME(3)+0;
+-----------|-------------|--------------+
| CURTIME() | CURTIME()+0 | CURTIME(3)+0 |
+-----------|-------------|--------------+
| 09:28:00  |       92800 |    92800.887 |
+-----------|-------------|--------------+
mysql> SELECT NOW(), NOW()+0, NOW(3)+0;
+---------------------|----------------|--------------------+
| NOW()               | NOW()+0        | NOW(3)+0           |
+---------------------|----------------|--------------------+
| 2012-08-15 09:28:00 | 20120815092800 | 20120815092800.889 |
+---------------------|----------------|--------------------+
```

## 日期中包含的两位数年份

日期中包含的两位数年份不能明确表示实际年份，具有歧义性。

对于 `DATETIME`、`DATE` 和 `TIMESTAMP` 类型，TiDB 遵循以下规则来消除歧义：

- 01 到 69 之间的值转换为 2001 到 2069 之间的值
- 70 到 99 之间的值转换为 1970 到 1999 之间的值

这些规则也适用于 `YEAR` 类型，但有一个例外：

当数字 `00` 插入到 `YEAR(4)` 时，结果是 0000 而不是 2000。

如果你想要结果为 2000，请指定值为 2000。

两位数年份在某些函数（如 `MIN()` 和 `MAX()`）中可能无法正确计算。对于这些函数，四位数格式更适合。
